---
title: "PROYECTO 1 ST"
format: html
editor: visual
---

# Series Temporales: Proyecto B1

```{r, echo=FALSE, include=FALSE}
#Librerías
library(tsibble)
library(dplyr)
library(lubridate)
library(fpp3)
library(tidyverse)
library(leaflet)
library(zoo)
library(fable)
library(imputeTS)
library(ggplot2)
library(tidyr)
library(stringr)
library(patchwork)
library(feasts)
library(knitr)

ruta<-"C:/Users/USER/OneDrive/Documentos/Trabajos R/10194650/so2_procesado.csv"
```

```{r, echo=FALSE}
datos_so2 <- read.csv(ruta, sep = ";")
head(datos_so2)
datos_so2 <- datos_so2 |>  mutate(FECHA=dmy(paste(DIA, MES, ANIO)))

so2_diario <- datos_so2 |> 
  mutate(SO2 = as.numeric(SO2)) 
```

Tomaremos como nuestro índice temporal a la variable *FECHA.*

Ahora, el estudio se realizará en la provincia de Pichincha, entonces, las series temporales consideradas se basarán en cada estación de cada cantón de la ciudad de Quito. Como primera instancia, se realizará un análisis de características de seis estaciones de interés; a saber, Belisario, Carapungo, Cotocollao, Tumbaco, (las dos que faltan). En conjunto, estas estaciones muestran un gran contraste en la tipología de exposición y las fuentes de emisión, puesto que algunas de ellas enfrentan diariamente una exposición y emisión alta de SO2 por la presencia de actividades humanas a comparación de otras.

```{r warning=FALSE, include=FALSE}
vector_estaciones <- c("Belisario", "Carapungo", "Cotocollao", "Tumbaco")

so2_ts <- so2_diario |> 
    filter(!is.na(SO2)) |> 
    filter(PROV == "Pichincha", ESTACION %in% vector_estaciones) |> 
    select(FECHA, ESTACION, SO2) |> 
    as_tsibble(index = FECHA, key = ESTACION) |> 
    fill_gaps() |> 
    mutate(SO2 = imputeTS::na_seadec(SO2, algorithm = "interpolation", 
                                     find_frequency = TRUE))

```

```{r, echo=FALSE}
serie_estaciones <- function(so2_diario, vector_estaciones) {
  
  so2_por_estaciones <- list()
  for(i in 1:length(vector_estaciones)){
    so2_por_estaciones[[i]] <- so2_ts |> 
      filter(ESTACION == vector_estaciones[i])
  }
  
  so2_por_estaciones
}

serie <- serie_estaciones(so2_diario, vector_estaciones)

```

Con la frecuencia diaria, pues, el SO2 al ser una sustancia muy volatil, es de interés saber los días que se alcanzan los máximos durante el año. Además que el SO2 suele estar ligado a la actividad humana, entonces, la medición diaria del SO2 tiene la capacidad de mostrar patrones cruciales. (REFERENCIA)

### Diversidad de las series de interés

#### Tendencia

```{r, echo=FALSE}

so2_ts |> 
  autoplot(SO2) +
  labs(title = "Estaciones", x="Tiempo") +
  facet_wrap(vars(ESTACION), scales = "free_y", ncol = 2) +
  theme(legend.position = "none")

```

#### Estacionalidad

```{r, echo=FALSE, warning=FALSE}

so2_ts |> 
  gg_season(SO2, labels="both") +
  labs(y="SO2 HG/m^3", x = "Tiempo",
       title = "Cantidad de SO2 en el aire por estaciones")

```

En el gráfico anterior se muestra que los primeros y últimos días de cada año, se da un efecto descendiente del SO2 en el aire, un patrón que como se explicó, se lo localiza por una frecuencia diaria.

#### Descomposición

El siguiente objetivo es ver el comportamiento de cada componente de la descomposición de ambas series.

```{r, echo=FALSE}
so2_ts |> 
  model(stl=STL(SO2)) |> 
  components() |> 
  autoplot() +
  labs(title = "Descomposición STL", x="Tiempo")
```

### Estacionaridad

#### ACF

```{r, echo=FALSE}

so2_ts |> 
  ACF(SO2, lag_max = 200) |> 
  autoplot() + 
  labs(title = "ACF de cantidad de SO2 por estación") +
  facet_wrap(vars(ESTACION), scales = "free_y", ncol = 2) +
  theme(legend.position = "none")

```

(MODIFICAR) Los gráficos de la ACF, muestran que existe auto-correlación con lags pasados. Como por ejemplo el caso de Belisario, posee una alta auto-correlación hasta un lag cercano a 200, a diferencia de la cantidad de SO2 en Carapungo, que muestra una correlación más fuerte con los lag cercanos a 3.

Podemos ver en la siguiente tabla de valores del ACF para las dos series.

```{r, echo=FALSE, warning=FALSE}
t1<-serie1%>%fill_gaps()%>%ACF(SO2, lag_max = 200)
t2<-serie2%>%fill_gaps()%>%ACF(SO2, lag_max = 200)

t1_resumen <- t1 %>% 
  arrange(desc(abs(acf))) %>% 
  head(5)

t2_resumen <- t2 %>% 
  arrange(desc(abs(acf))) %>% 
  head(5)


library(gt)
library(htmltools)

# Tabla 1
gt_t1 <- gt(as_tibble(t1_resumen)) %>%
  tab_header(title = "SO2 en Belisario") %>%
  fmt_number(columns = acf, decimals = 4)

# Tabla 2
gt_t2 <- gt(as_tibble(t2_resumen)) %>%
  tab_header(title = "SO2 en Carapungo") %>%
  fmt_number(columns = acf, decimals = 4)

div(
  style = "display: flex; justify-content: space-around; gap: 20px;",
  as.tags(gt_t1),
  as.tags(gt_t2)
)
```

Pero, es posible obtener un mejor acercamiento a la dependencia de la serie con los LAGS, pero primero se debe verificar si las series son Estacionarias o sino convertirlas con alguna transformación.

###### Método del ROLLMEAN

```{r, echo=FALSE, warning=FALSE}
so2_ts |> 
  mutate(mm=rollmean(SO2, k=5, fill = NA)) |> 
  autoplot(SO2) + 
  geom_line(aes(y=mm), colour="#D55E00") +
  labs(title = "Cantidad de SO2 por estación y la media puntual a lo largo del tiempo") +
  facet_wrap(vars(ESTACION), scales = "free_y", ncol = 2) +
  theme(legend.position = "none") +
  guides(color = "none") +
  scale_color_manual(values = rep("black", length(vector_estaciones)))
```

A simple vista, parecen ser ambas series no estacionarias, pues, en los años del 2005 al 2006, las medias presentan picos muy altos, además que existe también una homocedasticidad.

Probemos el Test de KPSS para determinar si son o no estacionarias:

```{r, echo=FALSE}
test1<-serie1%>%features(SO2, unitroot_kpss)
test2<-serie2%>%features(SO2, unitroot_kpss)
tabla<-bind_rows("Belisario test1"=as_tibble(test1), "Carapungo test2"=as_tibble(test2), .id = "Fuente")
tabla %>%
  kable(
    caption = "Resultados de la Prueba KPSS para las series en Belisario y Carapungo", 
    col.names = c("Fuente", "Estadístico", "Valor P"),       
    digits = 4                                    )
```

En ambos casos, por el test KPSS, se rechaza la idea que ambas series sean estacionarias pues, el *p-value* es menor o igual a 0.01.

Entonces para ver realmente alguna dependencia de las series con algún LAG, por medio del PACF (además de luego poder aplicar métodos de modelado) , necesitamos que las series sean estacionarias. La forma más sencilla podría ser una simple diferenciación de orden m, para ellos KPSS, otorga el orden de diferenciación

```{r, echo=FALSE}
m1<-serie1%>%features(SO2, unitroot_ndiffs)
m2<-serie2%>%features(SO2, unitroot_ndiffs)
vm1<-m1$ndiffs
vm2<-m2$ndiffs
df_ordenes <- data.frame(
  Serie = c("Serie 1 (SO2)", "Serie 2 (SO2)"),
  Orden_Requerido = c(vm1, vm2)
)
df_ordenes %>%
  kable(
    caption = "**Órdenes de Diferenciación Requeridas (ndiffs)**",
    col.names = c("Serie", "Orden (d)"),
    digits = 0
  )
```

Entonces basta con la diferencia de orden 1, para que nuestras series temporales sean Estacionarias:

```{r, echo=FALSE, warning=FALSE}
so2_ts |> 
  mutate(SO2_diff=difference(SO2)) |> 
  autoplot(SO2_diff) + 
  labs(title = "Serie diferenciada: \n Cantidad de SO2 por estación") +
  facet_wrap(vars(ESTACION), scales = "free_y", ncol = 2) +
  theme(legend.position = "none")
```

Ahora, con nuestras series transformadas a series estacionarias, la información del PACF será de interés.

#### PACF

```{r}
so2_ts |> 
  PACF(SO2) |> 
  autoplot() + 
  labs(title = "ACF de cantidad de SO2 por estación") +
  facet_wrap(vars(ESTACION), scales = "free_y", ncol = 2) +
  theme(legend.position = "none")

```

Por tanto, veamos los valores de la auto-correlación parcial con los distintos lags

```{r , echo=FALSE}
t3<-serie1_diff%>%fill_gaps()%>%PACF(SO2, lag_max = 200)
t4<-serie2_diff%>%fill_gaps()%>%PACF(SO2, lag_max = 200)

t3_resumen <- t3 %>% 
  arrange(desc(abs(pacf))) %>% 
  head(5)

t4_resumen <- t4 %>% 
  arrange(desc(abs(pacf))) %>% 
  head(5)


library(gt)
library(htmltools)

# Tabla 1
gt_t3 <- gt(as_tibble(t3_resumen)) %>%
  tab_header(title = "SO2 en Belisario") %>%
  fmt_number(columns = pacf, decimals = 4)

# Tabla 2
gt_t4 <- gt(as_tibble(t4_resumen)) %>%
  tab_header(title = "SO2 en Carapungo") %>%
  fmt_number(columns = pacf, decimals = 4)

div(
  style = "display: flex; justify-content: space-around; gap: 20px;",
  as.tags(gt_t3),
  as.tags(gt_t4)
)

```

Notamos entonces que existe una auto-correlación parcial significativa con el lag 1.

***Gracias a todo lo visto antes, el modelo se podría explicar como un AR(1)***

```{r, echo=FALSE, warning=FALSE}
resultado_vertical <- serie1 %>%
  features(SO2, feat_acf) %>%
  pivot_longer(
    cols = everything(),
    names_to = "Metrica",
    values_to = "Valor"
  )

resultado_vertical %>%
  gt() %>% 
  tab_header(
    title = "Características de Autocorrelación (ACF) para la Cantidad de SO2 en Belisario", 
    subtitle = "Resumen de feat_acf en formato vertical"
  ) %>%
  cols_label(
    Metrica = "Métrica de ACF",
    Valor = "Valor Calculado"
  )
```

```{r, echo=FALSE, warning=FALSE}
resultado_vertical <- serie2 %>%
  features(SO2, feat_acf) %>%
  pivot_longer(
    cols = everything(),
    names_to = "Metrica",
    values_to = "Valor"
  )

resultado_vertical %>%
  gt() %>% 
  tab_header(
    title = "Características de Autocorrelación (ACF) para la Cantidad de SO2 en Carapungo", 
    subtitle = "Resumen de feat_acf en formato vertical"
  ) %>%
  cols_label(
    Metrica = "Métrica de ACF",
    Valor = "Valor Calculado"
  )

```

Por las últimas tablas, podemos intuír que por el valor de *diff_acf1* basta con una diferencia de orden 1 para convertir ambas series en series estacionarias.

```{r, echo=FALSE}
serie1_diff<-serie1%>%mutate(SO2_diff=difference(SO2))

SO2diffmm1<- serie1_diff%>%mutate(mm1_diff=rollmean(SO2, k=5, fill = NA))
SO2diffmm1%>%autoplot(SO2_diff)+geom_line(aes(y=mm1_diff), colour="#D55E00")+
  labs(y = "SO2 HG/m^3",
       title = "Cantidad de SO2 en Belisario y la media puntual a lo largo del tiempo") +
  guides(colour = guide_legend(title = "series"))


```

## Quarto

Quarto enables you to weave together content and executable code into a finished document. To learn more about Quarto see <https://quarto.org>.

## Running Code

When you click the **Render** button a document will be generated that includes both content and the output of embedded code. You can embed code like this:

```{r}
1 + 1
```

You can add options to executable code like this

```{r}
#| echo: false
2 * 2
```

The `echo: false` option disables the printing of code (only output is displayed).
